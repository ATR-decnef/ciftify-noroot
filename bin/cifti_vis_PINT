#!/usr/bin/env python
"""
Makes temporary seed corr maps using a chosen roi for each network and
correlation maps

Usage:
    cifti_vis_PINT snaps [options] <func.dtseries.nii> <subject> <PINT_summary.csv>
    cifti_vis_PINT index [options]

Arguments:
    <func.dtseries.nii>        A dtseries file feed into find-PINT-vertices.py map
    <subject>                  Subject ID for HCP surfaces
    <PINT_summary.csv>         The output csv (*_summary.csv) from the PINT
                               analysis step

Options:
  --qcdir PATH             Full path to location of QC directory
  --hcp-data-dir PATH      The directory for HCP subjects (overrides HCP_DATA
                           enviroment variable)
  --subjects-filter STR    A string that can be used to filter out subject
                           directories
  --roi-radius MM          Specify the radius [default: 6] of the plotted rois
                           (in mm)
  -v,--verbose             Verbose logging
  --debug                  Debug logging in Erin's very verbose style
  -n,--dry-run             Dry run
  --help                   Print help

DETAILS
This makes pretty pictures of your hcp views using connectome workbenches
"show scene" commands. It pastes the pretty pictures together into some .html
QC pages

There are two subfunctions:

    snaps: will create all the pics as well as the subjects specific html view for
    one subject. This option requires the cifti file of functionl timeseries.
    The hcp subject id so that it can find the surface information to plot on.
    And the *_summary.csv file that was the output of find-PINT-vertices

    index: will make an index out of all the subjects in the qcdir

Note: this script requires the seaborn package to make the correlation heatmaps..

Written by Erin W Dickie (erin.w.dickie@gmail.com) Jun 20, 2016
"""
import os
import sys
import tempfile
import shutil
import logging
import logging.config

from docopt import docopt
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import seaborn as sns
sns.set(context="paper", font="monospace")
import pandas as pd
import numpy as np
import nibabel as nib

import ciftify
from ciftify.utilities import VisSettings

DRYRUN = False
DEBUG = False

# Read logging.conf
config_path = os.path.join(os.path.dirname(__file__), "logging.conf")
logging.config.fileConfig(config_path, disable_existing_loggers=False)
logger = logging.getLogger(os.path.basename(__file__))

PINTnets = [{ 'NETWORK': 2, 'roiidx': 72, 'best_view': "CombinedView"},
                { 'NETWORK': 3, 'roiidx': 2, 'best_view': "CombinedView"},
                { 'NETWORK': 4, 'roiidx': 44, 'best_view': "dtLat"},
                { 'NETWORK': 5, 'roiidx': 62, 'best_view': "dtLat"},
                { 'NETWORK': 6, 'roiidx': 28, 'best_view': "dtLat"},
                { 'NETWORK': 7, 'roiidx': 14, 'best_view': "dtLat"}]


### Erin's little function for running things in the shell
def docmd(cmdlist):
    "sends a command (inputed as a list) to the shell"
    global DRYRUN
    global DEBUG

    echo_cmd = True if DEBUG else False

    supress_stdout = False
    if "math" in cmdlist[0]: supress_stdout = True

    ciftify.utilities.run(cmdlist, dryrun=DRYRUN, echo = echo_cmd, supress_stdout = supress_stdout)

## to run qc
## copy qc_template.scene into your hcp directory as qc_views.scene
def png_SplitHorizontal(input_png,output_png,tmpdir):
    '''
    uses imagemagick to split the image top and bottom halves to one line
    '''
    docmd(['convert', input_png,\
        '-crop', '100x50%+0+0', os.path.join(tmpdir,'top.png')])
    docmd(['convert', input_png,\
        '-crop', '100x50%+0+200', os.path.join(tmpdir,'bottom.png')])
    docmd(['montage', '-mode', 'concatenate', '-tile', '2x1', \
        os.path.join(tmpdir,'top.png'),\
        os.path.join(tmpdir,'bottom.png'),\
        os.path.join(output_png)])

def make_heatmap(summary_df, meants, output_png):

    corrmat = meants.corr()
    # Set up the matplotlib figure
    f, ax = plt.subplots(figsize=(10, 8))

    # Draw the heatmap using seaborn
    sns.heatmap(corrmat, vmax=.9, square=True)

    # Use matplotlib directly to emphasize known networks
    for i in summary_df.index:
        if i and summary_df.loc[i,'NETWORK'] != summary_df.loc[i-1,'NETWORK']:
            ax.axhline(len(summary_df) - i, c="w",linewidth=3.0 )
            ax.axvline(i, c="w",linewidth=3.0)
    f.tight_layout()
    f.savefig(output_png)


def write_index(qcdir, subjects, pic_ending, colwidth, indexname, title):
    '''
    Writes html file with all subjects for one pic shown together
    '''
    # open the file
    htmlindex = open(os.path.join(qcdir,indexname),'w')

    # write the header and title line
    htmlindex.write('<!DOCTYPE html>\n<HTML><TITLE>{}</TITLE>\n'.format(title))
    ciftify.html.write_header(htmlindex)
    htmlindex.write('<body>\n')
    ## writing the navigation bar
    nav_list = [{'href': "", 'label':'Network:'}]
    for pint_dict in PINTnets:
        nav_list.append({ 'href': "network_{}.html".format(pint_dict['NETWORK']),
                           'label': pint_dict['NETWORK'] })
    nav_list.append({'href': "corrmats.html", 'label':'Correlation Matrixes'})
    nav_list.append({'href': "index.html", 'label':'Index'})
    ciftify.html.write_navbar(htmlindex,
                    "PINT results",
                    nav_list,
                    activelink  = indexname)

    ## add the main title
    htmlindex.write('<h1>{}</h1>\n'.format(title))

    # add the pic and a link to the subjects' page
    for subject in subjects:
        subjectpage = os.path.join(qcdir,subject,'qc_sub.html')
        htmlindex.write('<div class="container" style="width: 100%;">')
        for vert_type in ['tvertex','ivertex']:
            pic = os.path.join(qcdir,subject,'{}{}'.format(vert_type,pic_ending))
            picrelpath = os.path.relpath(pic,os.path.dirname(htmlindex.name))
            subrelpath = os.path.relpath(subjectpage,os.path.dirname(htmlindex.name))
            ciftify.html.add_image(htmlindex, colwidth,
                           subrelpath, picrelpath,
                           "{} {}".format(subject,vert_type))
        htmlindex.write('</div>\n</br>')
    ## close the html index stream
    htmlindex.write('</body>\n')
    htmlindex.close()

def write_all_indexpages(qcdir, subjects_filter, scene_list, montage_list):
    '''
    Makes all the indices.
    Arguments:
      qcdir: the output directory for all the qc
      subjects_filter: a string to use for filtering subject ids
      pint_dict: the dictionary of index settings
      scene_list: the list of dictionaries of information for each scene
      montage_list the list of dictionaries for montages created from scenes
    '''
    # get the subjects list
    subjects = ciftify.utilities.get_subj(qcdir)

    if subjects_filter:
        subjects = filter(lambda x: subjects_filter in x, subjects)

    ## write the major index
    indexhtml = os.path.join(qcdir, 'index.html')
    indexhtml = open(indexhtml,'w')
    indexhtml.write('<!DOCTYPE html>\n<HTML><TITLE>PINT results</TITLE>\n')
    ciftify.html.write_header(indexhtml)
    indexhtml.write('<body>\n')

    ## writing the navigation bar
    nav_list = [{'href': "", 'label':'Network:'}]
    for pint_dict in PINTnets:
        nav_list.append({ 'href': "network_{}.html".format(pint_dict['NETWORK']),
                           'label': pint_dict['NETWORK'] })
    nav_list.append({'href': "corrmats.html", 'label':'Correlation Matrixes'})
    nav_list.append({'href': "index.html", 'label':'Index'})
    ciftify.html.write_navbar(indexhtml,
                    "PINT results",
                    nav_list,
                    activelink = 'index.html')
    ## writing the lists to the main index page
    indexhtml.write('<h1>PINT results index</h1>\n')
    indexhtml.write('<h2>All subjects together</h2>\n')
    indexhtml.write('<ul>\n  ')
    indexhtml.write('<li><a href="corrmats.html">Correlation Matrixes</a></li>\n')
    for pint_dict in PINTnets:
        indexhtml.write('<li><a href="network_{}.html">Network {} Seed Correlations</a></li>\n'.format(pint_dict['NETWORK'], pint_dict['NETWORK']))
    indexhtml.write('</ul>\n')
    indexhtml.write('<h2>Subject Pages</h2>\n')
    indexhtml.write('<ul>\n  ')
    for subject in subjects:
        indexhtml.write('<li><a href="{}/qc_sub.html">{}</a></li>\n'.format(subject,subject))
    indexhtml.write('</ul>\n')
    indexhtml.write('</body>')
    indexhtml.close()

    # write the corrmat index
    write_index(qcdir, subjects,
                '_corrmat.png',
                "theme-table-image col-sm-6",
                'corrmats.html',
                "Correlation Matixes")
    for pint_dict in PINTnets:
        write_index(qcdir,
                    subjects,
                    '{}_{}.png'.format(pint_dict['NETWORK'],pint_dict['best_view']),
                    "theme-table-image col-sm-12",
                    'network_{}.html'.format(pint_dict['NETWORK']),
                    "Network {} Index".format(pint_dict['NETWORK']))

class UserSettings(VisSettings):
    def __init__(self, arguments):
        VisSettings(self, arguments, qc_mode='scrois')
        self.subject = arguments['<subject>']
        self.dtseries = arguments['<func.dtseries.nii>']
        self.pint_summary = arguments['<PINT_summary.csv>']
        self.subject_filter = arguments['--subjects-filter']
        self.roi_radius = arguments['--roi-radius']

def main(arguments):
    arguments  = docopt(__doc__)
    snaps      = arguments['snaps']
    index      = arguments['index']
    verbose    = arguments['--verbose']
    debug      = arguments['--debug']
    DRYRUN     = arguments['--dry-run']

    if verbose:
        logger.setLevel(logging.INFO)

    if debug:
        logger.setLevel(logging.DEBUG)

    logger.debug(arguments)

    settings = UserSettings(arguments)
    qc_config = ciftify.qc_config.Config(settings.qc_mode)

    ## make pics and qcpage for each subject
    if snaps:
        with ciftify.utilities.TempSceneDir(settings.hcp_dir,
                settings.subject) as scene_dir:
            logger.debug('Created tempdir {} on host {}'.format(scene_dir,
                    os.uname()[1]))
            logger.info("Making snaps for subject: {}".format(settings.subject))
            ret = run_snaps(settings, qc_config, scene_dir)
        return ret

    # Start the index html file
    if index:
        logger.info("Writing Index pages to: {}".format(qcdir))
        write_all_indexpages(qcdir, subjects_filter, scene_list, montage_list)

def run_snaps(settings, qc_config, scene_dir):
    '''
    Do all the qc stuff for the one subject.
    '''
    qc_subdir = os.path.join(settings.qc_dir, settings.subject)

    if os.path.exists(qc_subdir):
        logger.info('QC for subject {} already exists...exiting')
        return 0

    ciftify.utilities.make_dir(qc_subdir, dry_run=DRYRUN)

    with open(settings.template, 'r') as template_txt:
        template_contents = template_txt.read()

    if not template_contents:
        logger.error("{} cannot be read or is empty".format(settings.template))
        sys.exit(1)

    ## write the header for the subjects qc page
    qcsubhtml = os.path.join(qc_subdir, 'qc_sub.html')
    qcsubhtml = open(qcsubhtml,'w')
    qcsubhtml.write('<!DOCTYPE html>\n<HTML><TITLE> {} PINT results</TITLE>\n'.format(subject))
    ciftify.html.write_header(qcsubhtml)
    qcsubhtml.write('<body>\n')

    ## writing the navigation bar
    nav_list = [{'href': "", 'label':'Network:'}]
    for pint_dict in PINTnets:
        nav_list.append({ 'href': "../network_{}.html".format(pint_dict['NETWORK']),
                           'label': pint_dict['NETWORK'] })
    nav_list.append({'href': "../corrmats.html", 'label':'Correlation Matrixes'})
    nav_list.append({'href': "../index.html", 'label':'Index'})
    ciftify.html.write_navbar(qcsubhtml,
                    subject,
                    nav_list)

    ## writing the title
    qcsubhtml.write('<h1> {} PINT results</h1>\n'.format(subject))

    # ## make a tempdir for this subject
    # tmpdir = os.path.join(tmpdirbase,subject)
    # docmd(['mkdir','-p', tmpdir])

    if not os.path.isfile(func):
        logger.critical("{} not found".format(func))
        return(1)

######### Used way later for correlation stuff
    func_fnifti = os.path.join(tmpdir,'func.nii.gz')
    ## convert funcfile to fake nifti
    docmd(['wb_command','-cifti-convert','-to-nifti',func, func_fnifti])
    ## load functional file as nibabel object using ciftify-utilities
    f_data, affine, header, dims = ciftify.utilities.loadnii(func_fnifti)
    ## mean the fuctional cifti image to make cifti template for the output
    docmd(['wb_command', '-cifti-reduce', func, 'MIN', os.path.join(tmpdir, 'template.dscalar.nii')])

#########################################################


############## Could be moved within settings (Makes vertex matrix pics)
#### tvertex and ivertex csvs are hidden dependencies

    # Load the datset of correlations between cortical brain networks
    summary_df = pd.read_csv(summarycsv)
    tmeants = pd.read_csv(summarycsv.replace('_summary', '_tvertex_meants'), header=None).transpose()
    imeants = pd.read_csv(summarycsv.replace('_summary', '_ivertex_meants'), header=None).transpose()

    tvertex_corrpic = os.path.join(qc_subdir, 'tvertex_corrmat.png')
    ivertex_corrpic = os.path.join(qc_subdir, 'ivertex_corrmat.png')

    make_heatmap(summary_df, tmeants, tvertex_corrpic)
    make_heatmap(summary_df, imeants, ivertex_corrpic)

###########################################################

################################ Just adds the vertex pics to page
    ### write the section of the subject html page that contains the corrmat picks
    qcsubhtml.write('<div class="container" style="width: 100%;">')
    picrelpath = os.path.relpath(tvertex_corrpic,os.path.dirname(qcsubhtml.name))
    ciftify.html.add_image(qcsubhtml, 6, picrelpath, picrelpath,"Pre (tvertex)")
    picrelpath = os.path.relpath(ivertex_corrpic,os.path.dirname(qcsubhtml.name))
    ciftify.html.add_image(qcsubhtml, 6, picrelpath, picrelpath,"Post (ivertex)")
    qcsubhtml.write('</div>\n')

#############################################


    for pint_dict in PINTnets:
        '''
        for each seed vertex make an roi and generate a seed map
        '''
        ## get info from the seed_dict
        roiidx = pint_dict['roiidx']
        network = pint_dict['NETWORK']

        ## make a dscalar of the network map
        networkdf = summary_df.loc[summary_df.loc[:,'NETWORK'] == network,:]
        networkdf.to_csv(os.path.join(tmpdir,'networkdf.csv'),
                        index = False)

        qcsubhtml.write('<div class="container" style="width: 100%;">\n')
        qcsubhtml.write('  <h2>Network {}</h2>\n'.format(network))

        for vert_type in ['tvertex','ivertex']:

            logging.info('Running {} {} snaps:'.format(network, vert_type))

            xrois_dscalar = os.path.join(tmpdir,'xrois.dscalar.nii')
            rois_dscalar = os.path.join(tmpdir,'rois.dscalar.nii')

            ## make the overlaying ROIs
            docmd(['ciftify-surface-rois',
                    '--vertex-col', vert_type,
                    os.path.join(tmpdir,'networkdf.csv'),
                    str(SEED_RADIUS),
                    os.path.join(hcp_data_dir, subject, 'MNINonLinear','fsaverage_LR32k',
                        '{}.L.midthickness.32k_fs_LR.surf.gii'.format(subject)),
                    os.path.join(hcp_data_dir, subject, 'MNINonLinear','fsaverage_LR32k',
                        '{}.R.midthickness.32k_fs_LR.surf.gii'.format(subject)),
                    xrois_dscalar])

            ## make rois for alternative (if vertex_48 is in df, meaning failed to stop iterating)
            if vert_type == "ivertex" and 'vertex_48' in networkdf.columns:
                if networkdf.loc[:,'dist_49'].sum() > 0:
                    yrois_dscalar = os.path.join(tmpdir,'yrois.dscalar.nii')
                    ## make the overlaying ROIs
                    docmd(['ciftify-surface-rois',
                            '--vertex-col', 'vertex_48',
                            os.path.join(tmpdir,'networkdf.csv'),
                            str(SEED_RADIUS),
                            os.path.join(hcp_data_dir, subject, 'MNINonLinear','fsaverage_LR32k',
                                '{}.L.midthickness.32k_fs_LR.surf.gii'.format(subject)),
                            os.path.join(hcp_data_dir, subject, 'MNINonLinear','fsaverage_LR32k',
                                '{}.R.midthickness.32k_fs_LR.surf.gii'.format(subject)),
                            yrois_dscalar])

                else: yrois_dscalar = xrois_dscalar
            else: yrois_dscalar = xrois_dscalar

            ## combine both solutions into one roi result
            docmd(['wb_command -cifti-math "((x*2)+y)"',rois_dscalar,
                    '-var','x',xrois_dscalar,
                    '-var','y',yrois_dscalar])

            ## set the palette on the roi to power_surf (moslty grey)
            docmd(['wb_command', '-cifti-palette', rois_dscalar,
                'MODE_AUTO_SCALE', rois_dscalar,
                '-palette-name', 'power_surf'])

            ## makes the seedcorr_dscalar
            seedcorr_dscalar = os.path.join(tmpdir,'scorr{}{}.dscalar.nii'.format(
                                                    vert_type, network))

            if vert_type == 'ivertex':
                meants = imeants.loc[:,summary_df.loc[:,'NETWORK'] == network].mean(axis=1)
            if vert_type == 'tvertex':
                meants = tmeants.loc[:,summary_df.loc[:,'NETWORK'] == network].mean(axis=1)

            ## correlated the mean timeseries with the func data
            out = np.zeros([dims[0]*dims[1]*dims[2], 1])
            for i in np.arange(f_data.shape[0]):
                out[i] = np.corrcoef(meants, f_data[i, :])[0][1]
            ## reshape data and write it out to a fake nifti file
            out = out.reshape([dims[0], dims[1], dims[2], 1])
            out = nib.nifti1.Nifti1Image(out, affine)
            out.to_filename(os.path.join(tmpdir,'seedcorr{}.nii.gz'.format(network)))
            ## convert back
            docmd(['wb_command','-cifti-convert','-from-nifti',
                os.path.join(tmpdir,'seedcorr{}.nii.gz'.format(network)),
                os.path.join(tmpdir, 'template.dscalar.nii'),
                seedcorr_dscalar])

            docmd(['wb_command', '-cifti-palette', seedcorr_dscalar,
                'MODE_AUTO_SCALE_PERCENTAGE', seedcorr_dscalar,
                '-palette-name', 'PSYCH-NO-NONE'])


            ## copy out template .scene file and find and replace the subid and hcppath
            hcp_data_realpath = os.path.realpath(hcp_data_dir)
            scenefile = os.path.join(scenedir,'seedcorr_{}_{}{}.scene'.format(subject, network, vert_type))
            scenestream = open(scenefile,'w')
            scene_txt = template_txt.replace('HCP_DATA_PATH', hcp_data_realpath)
            scene_txt = scene_txt.replace('HCP_DATA_RELPATH', os.path.relpath(hcp_data_realpath,os.path.dirname(scenefile)))
            scene_txt = scene_txt.replace('SUBJID',subject)
            scene_txt = scene_txt.replace('SEEDMASKDIR', os.path.dirname(rois_dscalar))
            scene_txt = scene_txt.replace('SEEDMASKRELDIR', os.path.relpath(os.path.dirname(rois_dscalar),os.path.dirname(scenefile)))
            scene_txt = scene_txt.replace('SEEDMASKCIFTI', os.path.basename(rois_dscalar))
            scene_txt = scene_txt.replace('SEEDCORRDIR', os.path.dirname(seedcorr_dscalar))
            scene_txt = scene_txt.replace('SEEDCORRRELDIR', os.path.relpath(os.path.dirname(seedcorr_dscalar),os.path.dirname(scenefile)))
            scene_txt = scene_txt.replace('SEEDCORRCIFTI', os.path.basename(seedcorr_dscalar))
            scenestream.write(scene_txt)
            scenestream.close()

            ## write the header for the subjects qc page
            qchtml = os.path.join(qc_subdir, 'qc_{}{}.html'.format(vert_type, network))
            qchtml = open(qchtml,'w')
            qchtml.write('<!DOCTYPE html>\n<HTML><TITLE> {} {}{}</TITLE>\n'.format(subject,vert_type,network))
            ciftify.html.write_header(qchtml)
            qchtml.write('<body>\n')
            ciftify.html.write_navbar(qchtml,
                            "{} Network {} {}".format(subject, network, vert_type),
                            [{ 'href': "qc_sub.html", 'label': "Return to Subject Page"}])
            qchtml.write('<h1> {} network {} {} seed correlation </h1>\n'.format(subject,network, vert_type))

            ## for each scene, generate the pics and add to qc page
            for scene_dict in scene_list:
                if scene_dict['Keep']==True:
                    pic = os.path.join(qc_subdir,'{}{}_{}.png'.format(vert_type,network,scene_dict['Name']))
                    picrelpath = os.path.relpath(pic,os.path.dirname(qchtml.name))
                    ciftify.html.add_image(qchtml, 12, picrelpath, picrelpath,"")
                else:
                    pic = os.path.join(tmpdir,'{}{}_{}.png'.format(vert_type,network,scene_dict['Name']))
                if scene_dict['SplitHorizontal']==True:
                    tmppic = os.path.join(tmpdir, "scene{}.png".format(scene_dict['Idx']))
                    docmd(['wb_command', '-logging', 'WARNING', '-show-scene',
                            scenefile, str(scene_dict['Idx']),
                            tmppic,'600', '400'])
                    png_SplitHorizontal(tmppic,pic,tmpdir)
                else:
                    docmd(['wb_command', '-logging', 'WARNING', '-show-scene',
                            scenefile, str(scene_dict['Idx']),
                            pic,'600', '400'])

            for montage_dict in montage_list:
                pic = os.path.join(qc_subdir,'{}{}_{}.png'.format(vert_type,network,montage_dict['Name']))
                picrelpath = os.path.relpath(pic,os.path.dirname(qchtml.name))
                ciftify.html.add_image(qchtml, 12, picrelpath, picrelpath,"")
                montage_cmd=['montage', '-mode', 'concatenate', '-tile', montage_dict['Layout']]
                for subpic in montage_dict['Pics']:
                    #should add something that read scenelist to find if temp
                    montage_cmd.append(os.path.join(tmpdir,'{}{}_{}.png'.format(vert_type,network, subpic)))
                montage_cmd.append(pic)
                docmd(montage_cmd)


            favpic = os.path.join(qc_subdir,'{}{}_{}.png'.format(vert_type,network,pint_dict['best_view']))
            picrelpath = os.path.relpath(favpic,os.path.dirname(qcsubhtml.name))
            subrelpath = os.path.relpath(qchtml.name,os.path.dirname(qcsubhtml.name))
            ciftify.html.add_image(qcsubhtml, 12, subrelpath, picrelpath,
                            "Network {} {}".format(network, vert_type))
            ## close the htmlpage stream
            qchtml.close()

        ## add a div around the subject page container
        qcsubhtml.write('</div>\n')

    ## close the subject's htmlpage stream
    qcsubhtml.close()

if __name__=='__main__':
    ret = main()
    sys.exit(ret)
