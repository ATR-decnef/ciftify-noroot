#!/usr/bin/env python
"""
Makes pictures of standard views from the hcp files and pastes them
together into a qcpage.

Usage:
    cifti_vis_func2hcp snaps [options] <OutputBasename> <SmoothingFWHM> <subject>
    cifti_vis_func2hcp index [options]

Arguments:
  <OutputBasename>         OutputBasename argument given during func2hcp
  <SmoothingFWHM>          SmoothingFWHM argument given during func2hcp
  <subject>                Subject ID to process

Options:
  --qcdir PATH             Full path to location of QC directory
  --hcp-data-dir PATH      The directory for HCP subjects (overrides HCP_DATA
                           environment variable)
  --debug                  Debug logging in Erin's very verbose style
  -n,--dry-run             Dry run
  --help                   Print help

DETAILS
This makes pretty pictures of your hcp views using connectome workbenches "show
scene" commands. It pastes the pretty pictures together into some .html QC pages

This produces:
 ++ views of the functional data that has been projected to the "cifti space"
 ++ used to QC the volume to cortex mapping step - as well as subcortical
 ++ resampling this option requires that 2 more arguments are specified
    ++ --NameOffMRI and --SmoothingFWHM -
    ++ these should match what was input in the func2hcp command

Also this function works by writing a temporary file into the HCP_DATA directory,
therefore, write permission in the HCP_DATA directory is required.

Requires connectome workbench (i.e. wb_command and imagemagick)

Written by Erin W Dickie, Feb 2016
"""

import os
import glob
import sys
import tempfile
import shutil
import logging
import logging.config

from docopt import docopt

import ciftify
from ciftify.utilities import VisSettings

DRYRUN = False
DEBUG = False

class UserSettings(VisSettings):
    def __init__(self, arguments):
        VisSettings.__init__(self, arguments, qc_mode='func2cifti')
        self.fmri_name = arguments['<OutputBasename>']
        self.fwhm = arguments['<SmoothingFWHM>']
        self.subject = arguments['<subject>']

def main():
    global DEBUG, DRYRUN
    arguments       = docopt(__doc__)
    snaps_only      = arguments['snaps']
    index_only      = arguments['index']
    DEBUG           = arguments['--debug']
    DRYRUN          = arguments['--dry-run']

    if DEBUG:
        logger.setLevel(logging.DEBUG)

    logger.debug(arguments)

    user_settings = UserSettings(arguments)
    config = ciftify.qc_config.Config(user_settings.qc_mode)

    if snaps_only:
        write_single_qc_page(user_settings, config)
        return

    write_index_pages(user_settings.qc_dir, config, user_settings.qc_mode)

def write_single_qc_page(user_settings, config):
    """
    Generates a QC page for the subject specified by the user.
    """
    qc_dir = os.path.join(user_settings.qc_dir,
            '{}_{}_sm{}'.format(user_settings.subject, user_settings.fmri_name,
            user_settings.fwhm))
    qc_html = os.path.join(qc_dir, 'qc.html')

    if os.path.isfile(qc_html):
        # Page exists, do no work.
        return

    with ciftify.utilities.TempSceneDir(user_settings.hcp_dir,
            user_settings.subject) as scene_dir:
        generate_qc_page(user_settings, config, qc_dir, scene_dir, qc_html)

def generate_qc_page(user_settings, config, qc_dir, scene_dir, qc_html):
    scene_file = personalize_template(config.template, scene_dir, user_settings)
    change_sbref_palette(user_settings)

    if DRYRUN:
        return

    ciftify.utilities.make_dir(qc_dir, DRYRUN)
    with open(qc_html, 'w') as qc_page:
        add_page_header(qc_page, config, user_settings.qc_mode,
                subject=user_settings.subject)
        add_images(qc_page, qc_dir, config.images, scene_file)

def personalize_template(template, output_dir, user_settings):
    """
    Modify a copy of the given template to match the user specified values.
    """
    with open(template, 'r') as template_txt:
        template_contents = template_txt.read()

    if not template_contents:
        logger.error("{} cannot be read or is empty".format(template))
        sys.exit(1)

    scene_file = os.path.join(output_dir,
            'qc{}_{}.scene'.format(user_settings.qc_mode,
            user_settings.subject))

    with open(scene_file,'w') as scene_stream:
        new_text = modify_template_contents(template_contents, user_settings)
        scene_stream.write(new_text)

    return scene_file

def modify_template_contents(template_contents, user_settings):
    """
    Customizes a template file to a specific hcp data directory, by
    replacing all relative path references and place holder paths
    with references to specific files.
    """
    modified_text = template_contents.replace('HCP_DATA_PATH',
            user_settings.hcp_dir)
    modified_text = modified_text.replace('SUBJID', user_settings.subject)
    modified_text = modified_text.replace('RSLTDIR', user_settings.fmri_name)
    modified_text = modified_text.replace('DTSERIESFILE',
            '{}_Atlas_s{}.dtseries.nii'.format(user_settings.fmri_name,
            user_settings.fwhm))
    modified_text = modified_text.replace('SBREFFILE',
            '{}_SBRef.nii.gz'.format(user_settings.fmri_name))
    return modified_text

def change_sbref_palette(user_settings):
    sbref_nii = os.path.join(user_settings.hcp_dir, user_settings.subject,
            'MNINonLinear', 'Results', user_settings.fmri_name,
            '{}_SBRef.nii.gz'.format(user_settings.fmri_name))

    ciftify.utilities.docmd(['wb_command', '-volume-palette',
        sbref_nii,
        'MODE_AUTO_SCALE_PERCENTAGE',
        '-disp-neg', 'false',
        '-pos-percent', '25','98',
        '-thresholding', 'THRESHOLD_TYPE_NORMAL', 'THRESHOLD_TEST_SHOW_OUTSIDE',
        '-500', '500',
        '-palette-name','fsl_red'], DRYRUN)

def add_page_header(html_page, config, qc_mode, subject=None, active_link=None,
        path='', title=None):

    if title is None:
        title = qc_mode

    first_line = '<!DOCTYPE html>\n<HTML><TITLE>'
    if subject is not None:
        first_line = first_line + " qc {}".format(subject)
    first_line = first_line + " {} </TITLE>\n".format(title)

    html_page.write(first_line)
    ciftify.html.write_header(html_page)

    html_page.write('<body>\n')
    nav_list = get_navigation_list(config, path)
    ciftify.html.write_navbar(html_page, qc_mode, nav_list, active_link)

    if subject is not None:
        html_page.write('\n<h1>QC {} {}</h1>\n'.format(subject, qc_mode))

def get_navigation_list(config, path=''):
    nav_list = [{'href': '', 'label':'View:'}]

    for image in config.images:
        if image.make_index:
            image_path = os.path.join(path, '{}.html'.format(image.name))
            nav_list.append({ 'href': image_path,
                               'label': image.name})

    index_path = os.path.join(path, 'index.html')
    nav_list.append({'href': index_path, 'label':'Index'})

    return nav_list

def add_images(qc_page, qc_dir, image_list, scene_file):
    """
    Takes a list of scenes and montages, generates them, and adds them to
    qc_page.
    """
    for image in image_list:
        pic_name = "{}.png".format(image.name)
        ciftify.html.add_image(qc_page, 12, pic_name, pic_name, "")
        output_path = os.path.join(qc_dir, pic_name)
        image.make_image(output_path, scene_file)

def write_index_pages(qc_dir, config, qc_mode):
    subjects = ciftify.utilities.get_subj(qc_dir)

    index_html = os.path.join(qc_dir, 'index.html')
    with open(index_html,'w') as index_page:
        add_page_header(index_page, config, qc_mode, active_link='index.html')
        index_page.write('<h1>{} Index</h1>\n'.format(qc_mode))
        add_image_and_subject_index(index_page, config, subjects)

    for image in config.images:
        if not image.make_index:
            continue
        write_image_index(qc_dir, subjects, config, qc_mode,
                    "{}.png".format(image.name),
                    "{}.html".format(image.name),
                    "{} View Index ({} space)".format(image.name, qc_mode))

def add_image_and_subject_index(index_page, config, subjects):
    index_page.write('<h2>All subjects together</h2>\n')
    index_page.write('<ul>\n  ')
    for image in config.images:
        if not image.make_index:
            continue
        index_page.write('<li><a href="{}.html">{} View</a>' \
                '</li>\n'.format(image.name, image.name))
    index_page.write('</ul>\n')
    index_page.write('<h2>Subject Pages</h2>\n')
    index_page.write('<ul>\n  ')
    for subject in subjects:
        index_page.write('<li><a href="{}/qc.html">{}</a>' \
                '</li>\n'.format(subject, subject))
    index_page.write('</ul>\n')
    index_page.write('</body>')

def write_image_index(qc_dir, subjects, config, qc_mode, pic_name, index_name,
        title, colwidth=12):
    '''
    Writes html file with all subjects for one pic shown together
    '''
    # open the file
    html_index = os.path.join(qc_dir, index_name)
    with open(html_index, 'w') as image_page:
        add_page_header(image_page, config, qc_mode, title=title,
                active_link=index_name)
        ## add the main title
        image_page.write('<h1>{}</h1>\n'.format(title))
        for subject in subjects:
            add_image_and_subject_page_link(image_page, subject, pic_name,
                    colwidth)
        ## close the html page
        image_page.write('</body>\n')

def add_image_and_subject_page_link(image_page, subject, pic_name, colwidth):
    image_page.write('<div class="container" style="width: 100%;">')
    subject_page = os.path.join('{}'.format(subject), 'qc.html')
    pic = os.path.join('{}'.format(subject), pic_name)
    ciftify.html.add_image(image_page, colwidth, subject_page, pic, subject)
    image_page.write('</div>\n</br>')

if __name__ == '__main__':
    # Read logging.conf
    config_path = os.path.join(os.path.dirname(__file__), "logging.conf")
    logging.config.fileConfig(config_path, disable_existing_loggers=False)
    logger = logging.getLogger(os.path.basename(__file__))

    main()
