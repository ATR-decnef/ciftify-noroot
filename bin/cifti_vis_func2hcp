#!/usr/bin/env python
"""
Makes pictures of standard views from the hcp files and pastes them
together into a qcpage.

Usage:
    cifti_vis_func2hcp snaps [options] <OutputBasename> <SmoothingFWHM> <subject>
    cifti_vis_func2hcp index [options]

Arguments:
  <OutputBasename>         OutputBasename argument given during func2hcp
  <SmoothingFWHM>          SmoothingFWHM argument given during func2hcp
  <subject>                Subject ID to process

Options:
  --qcdir PATH             Full path to location of QC directory
  --hcp-data-dir PATH      The directory for HCP subjects (overrides HCP_DATA
                           environment variable)
  --debug                  Debug logging in Erin's very verbose style
  -n,--dry-run             Dry run
  --help                   Print help

DETAILS
This makes pretty pictures of your hcp views using connectome workbenches "show
scene" commands. It pastes the pretty pictures together into some .html QC pages

This produces:
 ++ views of the functional data that has been projected to the "cifti space"
 ++ used to QC the volume to cortex mapping step - as well as subcortical resampling
 ++ this option requires that 2 more arguments are specified
    ++ --NameOffMRI and --SmoothingFWHM -
    ++ these should match what was input in the func2hcp command

Also this function works by writing a temporary file into the HCP_DATA directory,
therefore, write permission in the HCP_DATA directory is required.

Requires connectome workbench (i.e. wb_command and imagemagick)

Written by Erin W Dickie, Feb 2016
"""

import os
import subprocess
import glob
import sys
import tempfile
import shutil
import logging
import logging.config

from docopt import docopt

import ciftify

DRYRUN = False
DEBUG = False

def main():
    arguments       = docopt(__doc__)
    snaps_only      = arguments['snaps']
    index_only      = arguments['index']
    DEBUG           = arguments['--debug']
    DRYRUN          = arguments['--dry-run']

    if DEBUG:
        logging.setLevel(logging.DEBUG)

    logging.debug(arguments)

    user_settings = UserSettings(arguments, qc_mode='func2cifti')
    config = ciftify.qc_config.Config(user_settings.qc_mode)

    if snaps_only:
        make_single_qc_page(user_settings, config)
        return

    make_index_page(user_settings.qc_dir, config, user_settings.qc_mode)

class UserSettings(object):
    def __init__(self, arguments, qc_mode):
        self.qc_mode = qc_mode
        self.fmri_name = arguments['<OutputBasename>']
        self.fwhm = arguments['<SmoothingFWHM>']
        self.subject = arguments['<subject>']
        self.hcp_dir = self.__set_hcp_dir(arguments['--hcp-data-dir'])
        self.qc_dir = self.__set_qc_dir(arguments['--qcdir'])

    def __set_hcp_dir(self, user_dir):
        if user_dir:
            return user_dir
        found_dir = ciftify.config.find_hcp_data()
        if found_dir is None:
            logging.error("Cannot find HCP data directory, exiting.")
            sys.exit(1)
        return found_dir

    def __set_qc_dir(self, user_qc_dir):
        if user_qc_dir:
            return user_qc_dir
        qc_dir = os.path.join(self.hcp_dir, 'qc_{}'.format(self.qc_mode))

def make_single_qc_page(user_settings, config):
    """
    Generates a QC page for the subject specified by the user.
    """
    qc_dir = os.path.join(user_settings.qc_dir,
            '{}_{}_sm{}'.format(user_settings.subject, user_settings.fmri_name,
            user_settings.fwhm))
    qc_html = os.path.join(qc_dir, 'qc_{}.html'.format(user_settings.subject))

    if os.path.isfile(qc_html):
        return

    with TempDir() as temp_base_dir:
        tmp_dir = os.path.join(temp_base_dir, user_settings.subject)
        make_dir(tmp_dir)
        scene_temp_name = 'scene{}'.format(os.path.basename(temp_base_dir))
        with TempSceneDir(user_settings.hcp_dir, scene_temp_name) as scene_dir:
            generate_qc_page(user_settings, config, qc_dir, tmp_dir, scene_dir,
                    qc_html)

def generate_qc_page(user_settings, config, qc_dir, tmp_dir, scene_dir, qc_html):
    scene_file = personalize_template(config.template, scene_dir, user_settings)
    change_sbref_palette(user_settings)

    make_dir(qc_dir)
    with open(qc_html, 'w') as qc_page:
        add_page_header(qc_page, config, user_settings)
        for scene in config.scenes:
            add_scene(scene, qc_page, qc_dir, tmp_dir, scene_file)
        for montage in config.montages:
            add_montage(montage, qc_page, qc_dir, tmp_dir)

class TempSceneDir(object):
    """
    A context manager for the temporary scene dir.

    A temp dir in the same directory as the hcp data is used for the scene
    file due to the fact that scene files contain a large number of relative
    paths and the images will come out broken if it is put anywhere else.
    """
    def __init__(self, hcp_dir, temp_scene_dir_name):
        self.dir = os.path.join(hcp_dir, temp_scene_dir_name)

    def __enter__(self):
        make_dir(self.dir)
        return self.dir

    def __exit__(self, type, value, traceback):
        if not DEBUG: shutil.rmtree(self.dir)

class TempDir(object):
    def __init__(self):
        self.path = None
        return

    def __enter__(self):
        self.path = tempfile.mkdtemp()
        return self.path

    def __exit__(self, type, value, traceback):
        if self.path is not None:
            shutil.rmtree(self.path)

def personalize_template(template, output_dir, user_settings):
    """
    Modify a copy of the given template to match the user specified values.
    """
    with open(template, 'r') as template_txt:
        template_contents = template_txt.read()

    if not template_contents:
        logging.error("{} cannot be read or is empty".format(template))

    scene_file = os.path.join(output_dir,
            'qc{}_{}.scene'.format(user_settings.qc_mode,
            user_settings.subject))

    with open(scene_file,'w') as scene_stream:
        new_text = modify_template_contents(template_contents, user_settings)
        scene_stream.write(new_text)

    return scene_file

def modify_template_contents(template_contents, user_settings):
    """
    Customizes a template file to a specific hcp data directory, by
    replacing all relative path references and place holder paths
    with references to specific files.
    """
    modified_text = template_contents.replace('HCP_DATA_PATH',
            user_settings.hcp_dir)
    modified_text = modified_text.replace('SUBJID', user_settings.subject)
    modified_text = modified_text.replace('RSLTDIR', user_settings.fmri_name)
    modified_text = modified_text.replace('DTSERIESFILE',
            '{}_Atlas_s{}.dtseries.nii'.format(user_settings.fmri_name,
            user_settings.fwhm))
    modified_text = modified_text.replace('SBREFFILE',
            '{}_SBRef.nii.gz'.format(user_settings.fmri_name))
    return modified_text

def change_sbref_palette(user_settings):
    sbref_nii = os.path.join(user_settings.hcp_dir, user_settings.subject,
            'MNINonLinear', 'Results', user_settings.fmri_name,
            '{}_SBRef.nii.gz'.format(user_settings.fmri_name))

    docmd(['wb_command', '-volume-palette',
        sbref_nii,
        'MODE_AUTO_SCALE_PERCENTAGE',
        '-disp-neg', 'false',
        '-pos-percent', '25','98',
        '-thresholding', 'THRESHOLD_TYPE_NORMAL', 'THRESHOLD_TEST_SHOW_OUTSIDE',
        '-500', '500',
        '-palette-name','fsl_red'])

def add_page_header(qc_page, config, user_settings):
    qc_page.write('<!DOCTYPE html>\n<HTML><TITLE> qc {} {}' \
            ' </TITLE>\n'.format(user_settings.subject, user_settings.qc_mode))
    ciftify.html.write_header(qc_page)
    qc_page.write('<body>\n')

    nav_list = get_navigation_list(config)

    ciftify.html.write_navbar(qc_page,
                    user_settings.qc_mode,
                    nav_list)
    qc_page.write('\n<h1>QC {} {}</h1>\n'.format(user_settings.subject,
            user_settings.qc_mode))

def get_navigation_list(config):
    nav_list = [{'href': '', 'label':'View:'}]

    for scene_dict in config.scenes:
        if scene_dict['MakeIndex']==True:
            nav_list.append({ 'href': "../{}.html".format(scene_dict['Name']),
                               'label': scene_dict['Name'] })

    for montage_dict in config.montages:
        if montage_dict['MakeIndex']==True:
            nav_list.append({ 'href': "../{}.html".format(montage_dict['Name']),
                              'label': montage_dict['Name'] })
    nav_list.append({'href': "../index.html", 'label':'Index'})

    return nav_list

def add_scene(scene, qc_page, output_dir, tmp_dir, scene_file):
    pic_name = '{}.png'.format(scene['Name'])

    if scene['Keep']==True:
        # Output location is the qc_page folder, add it to the html
        pic_path = os.path.join(output_dir, pic_name)
        ciftify.html.add_image(qc_page, 12, pic_name, pic_name, "")
    else:
        pic_path  = os.path.join(tmp_dir, pic_name)

    if not scene['SplitHorizontal']:
        docmd(['wb_command', '-logging', 'WARNING', '-show-scene',
                scene_file, str(scene['Idx']),
                pic_path,'600', '400'])
        return

    tmp_pic = os.path.join(tmp_dir, "scene{}.png".format(scene['Idx']))
    docmd(['wb_command', '-logging', 'WARNING', '-show-scene',
            scene_file, str(scene['Idx']),
            tmp_pic,'600', '400'])
    png_SplitHorizontal(tmp_pic, pic_path, tmp_dir)


def add_montage(montage, qc_page, output_dir, tmp_dir):
    montage_name = '{}.png'.format(montage['Name'])
    pic = os.path.join(output_dir, montage_name)
    ciftify.html.add_image(qc_page, 12, montage_name, montage_name, "")
    montage_cmd=['montage', '-mode', 'concatenate', '-tile', montage['Layout']]
    for subpic in montage['Pics']:
        #should add something that read scenelist to find if temp
        montage_cmd.append(os.path.join(tmp_dir,'{}.png'.format(subpic)))
    montage_cmd.append(pic)
    docmd(montage_cmd)

# def make_index_page(qc_dir, config, qc_mode):
#     subjects = ciftify.utilities.get_subj(qc_dir)
#
#     ## write the major index
#     indexhtml = os.path.join(qc_dir, 'index.html')
#     indexhtml = open(indexhtml,'w')
#     indexhtml.write('<!DOCTYPE html>\n<HTML><TITLE>{}</TITLE>\n'.format(qc_mode))
#     ciftify.html.write_header(indexhtml)
#     indexhtml.write('<body>\n')
#
#     ## writing the navigation bar
#     nav_list = [{'href': "", 'label':'View:'}]
#     for scene_dict in config.scenes:
#         if scene_dict['MakeIndex']==True:
#             nav_list.append({ 'href': "{}.html".format(scene_dict['Name']),
#                                'label': scene_dict['Name'] })
#     for montage_dict in config.montages:
#         if montage_dict['MakeIndex']==True:
#                 nav_list.append({ 'href': "{}.html".format(montage_dict['Name']),
#                                    'label': montage_dict['Name'] })
#     nav_list.append({'href': "index.html", 'label':'Index'})
#     ciftify.html.write_navbar(indexhtml,
#                     qc_mode,
#                     nav_list,
#                     activelink = 'index.html')
#
#     ## writing the lists to the main index page
#     indexhtml.write('<h1>{} Index</h1>\n'.format(qc_mode))
#     indexhtml.write('<h2>All subjects together</h2>\n')
#     indexhtml.write('<ul>\n  ')
#     for scene_dict in config.scenes:
#         if scene_dict['MakeIndex']==True:
#             indexhtml.write('<li><a href="{}.html">{} View</a></li>\n'.format(scene_dict['Name'], scene_dict['Name']))
#     for montage_dict in config.montages:
#         if montage_dict['MakeIndex']==True:
#                 indexhtml.write('<li><a href="{}.html">{} View</a></li>\n'.format(montage_dict['Name'], montage_dict['Name']))
#     indexhtml.write('</ul>\n')
#     indexhtml.write('<h2>Subject Pages</h2>\n')
#     indexhtml.write('<ul>\n  ')
#     for subject in subjects:
#         indexhtml.write('<li><a href="{}/qc.html">{}</a></li>\n'.format(subject,subject))
#     indexhtml.write('</ul>\n')
#     indexhtml.write('</body>')
#     indexhtml.close()
#
#     for scene_dict in config.scenes:
#         if scene_dict['MakeIndex']==True:
#             write_index(qc_dir, subjects,
#                         "{}.png".format(scene_dict['Name']), 12,
#                         "{}.html".format(scene_dict['Name']),
#                         "{} View Index ({} space)".format(scene_dict['Name'],qc_mode))
#     for montage_dict in config.montages:
#         if montage_dict['MakeIndex']==True:
#             write_index(qc_dir, subjects,
#                         "{}.png".format(montage_dict['Name']), 12,
#                         "{}.html".format(montage_dict['Name']),
#                         "{} View Index ({} space)".format(montage_dict['Name'],qc_mode))

def make_dir(dir_name):
    if DRYRUN:
        logging.debug("Dry-run, skipping creation of directory {}".format(dir_name))
        return

    try:
        os.makedirs(dir_name)
    except OSError:
        logging.debug("{} already exists.")


### Erin's little function for running things in the shell
def docmd(cmdlist):
    "sends a command (inputed as a list) to the shell"
    logging.debug(' '.join(cmdlist))
    if not DRYRUN: subprocess.call(cmdlist)

## to run qc
## copy qc_template.scene into your hcp directory as qc_views.scene
def png_SplitHorizontal(input_png,output_png,tmpdir):
    '''
    uses imagemagick to split the image top and bottom halves to one line
    '''
    docmd(['convert', input_png,\
        '-crop', '100x50%+0+0', os.path.join(tmpdir,'top.png')])
    docmd(['convert', input_png,\
        '-crop', '100x50%+0+200', os.path.join(tmpdir,'bottom.png')])
    docmd(['montage', '-mode', 'concatenate', '-tile', '2x1', \
        os.path.join(tmpdir,'top.png'),\
        os.path.join(tmpdir,'bottom.png'),\
        os.path.join(output_png)])

# def write_index(qc_dir, subjects, pic_name, colwidth, indexname, title):
#     '''
#     Writes html file with all subjects for one pic shown together
#     '''
#     # open the file
#     htmlindex = open(os.path.join(qc_dir,indexname),'w')
#
#     # write the header and title line
#     htmlindex.write('<!DOCTYPE html>\n<HTML><TITLE>{}</TITLE>\n'.format(title))
#     ciftify.html.write_header(htmlindex)
#     htmlindex.write('<body>\n')
#     ## writing the navigation bar
#     nav_list = [{'href': "", 'label':'View:'}]
#     for scene_dict in config.scenes:
#         if scene_dict['MakeIndex']==True:
#             nav_list.append({ 'href': "{}.html".format(scene_dict['Name']),
#                                'label': scene_dict['Name'] })
#     for montage_dict in config.montages:
#         if montage_dict['MakeIndex']==True:
#                 nav_list.append({ 'href': "{}.html".format(montage_dict['Name']),
#                                    'label': montage_dict['Name'] })
#     nav_list.append({'href': "index.html", 'label':'Index'})
#     ciftify.html.write_navbar(htmlindex,
#                     qc_mode,
#                     nav_list,
#                     activelink = indexname)
#
#     ## add the main title
#     htmlindex.write('<h1>{}</h1>\n'.format(title))
#
#     # add the pic and a link to the subjects' page
#     for subject in subjects:
#         subjectpage = os.path.join(qc_dir,'{}'.format(subject),'qc.html')
#         htmlindex.write('<div class="container" style="width: 100%;">')
#         pic = os.path.join(qc_dir,'{}'.format(subject) ,pic_name)
#         picrelpath = os.path.relpath(pic,os.path.dirname(htmlindex.name))
#         subrelpath = os.path.relpath(subjectpage,os.path.dirname(htmlindex.name))
#         ciftify.html.add_image(htmlindex, colwidth,
#                        subrelpath, picrelpath,
#                        "{}".format(subject))
#         htmlindex.write('</div>\n</br>')
#     ## close the html index stream
#     htmlindex.write('</body>\n')
#     htmlindex.close()

if __name__ == '__main__':
    # Read logging.conf
    config_path = os.path.join(os.path.dirname(__file__), "logging.conf")
    logging.config.fileConfig(config_path, disable_existing_loggers=False)
    logger = logging.getLogger(os.path.basename(__file__))

    main()
