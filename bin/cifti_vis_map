#!/usr/bin/env python
"""
Creates pngs of standard surface and subcortical views from a nifti of cifti
input map.

Usage:
    cifti_vis_map cifti-snaps [options] <map.dscalar.nii> <subject> <map-name>
    cifti_vis_map nifti-snaps [options] <map.nii> <subject> <map-name>
    cifti_vis_map index [options] <map-name>

Arguments:
    <map.dscalar.nii>        A 2D cifti dscalar file to view
    <map.nii>                A 3D nifti file to view to view
    <subject>                Subject ID for HCP surfaces
    <map-name>               Name of dscalar map as it will appear in qc page
                             filenames

Options:
  --qcdir PATH             Full path to location of QC directory.
  --roi-overlay FILE       A mask of seeds you may want to overlay on your seed
                           correlation maps
  --hcp-data-dir PATH      The directory for HCP subjects (overrides HCP_DATA
                           enviroment variable)
  --subjects-filter STR    A string that can be used to filter out subject
                           directories
  --colour-palette STR     Specify the colour palette for the seed correlation
                           maps
  --output-dscalar FILE    Specify the output filename, if you would like the
                           dscalar file saved (from nifti-snaps)
  --resample-nifti         The nifti file needs to be resampled to the voxel
                           space of the hcp subject first
  --v,--verbose            Verbose logging
  --debug                  Debug logging in Erin's very verbose style
  -n,--dry-run             Dry run
  --help                   Print help

DETAILS
Requires connectome workbench (i.e. wb_command and imagemagick)

This makes pretty pictures of your hcp views using connectome workbenches
"show scene" commands. It pastes the pretty pictures together into some .html
QC pages.

Also this function works by writing a temporary file into the HCP_DATA
directory, therefore, write permission in the HCP_DATA directory is required.

By default, all folder in the qc directory will be included in the index.

You can change the color palette for all pics using the --colour-palette flag.
The default colour palette is videen_style. Some people like 'PSYCH-NO-NONE'
better. For more info on palettes see wb_command help.

Written by Erin W Dickie, Feb 2016
"""
import os
import glob
import sys
import tempfile
import shutil
import logging
import logging.config

import pandas as pd
import numpy as np
import nibabel as nib
from docopt import docopt

import ciftify
from ciftify.utilities import VisSettings

DRYRUN = False
DEBUG = False

config_path = os.path.join(os.path.dirname(__file__), "logging.conf")
logging.config.fileConfig(config_path, disable_existing_loggers=False)
logger = logging.getLogger(os.path.basename(__file__))

## copy qc_template.scene into your hcp directory as qc_views.scene
def png_SplitHorizontal(input_png,output_png,tmpdir):
    '''
    uses imagemagick to split the image top and bottom halves to one line
    '''
    ciftify.utilities.docmd(['convert', input_png,\
        '-crop', '100x50%+0+0', os.path.join(tmpdir,'top.png')])
    ciftify.utilities.docmd(['convert', input_png,\
        '-crop', '100x50%+0+200', os.path.join(tmpdir,'bottom.png')])
    ciftify.utilities.docmd(['montage', '-mode', 'concatenate', '-tile', '2x1', \
        os.path.join(tmpdir,'top.png'),\
        os.path.join(tmpdir,'bottom.png'),\
        os.path.join(output_png)])

def write_index(qcdir, subjects, mapname, pic_name,
                colwidth, indexname, title, qc_dict):
    '''
    Writes html file with all subjects for one pic shown together
    '''
    ## read the dictonaries of options
    scene_list = qc_dict['scene_list']
    montage_list = qc_dict['montage_list']

    # open the file
    htmlindex = open(os.path.join(qcdir,indexname),'w')

    # write the header and title line
    htmlindex.write('<!DOCTYPE html>\n<HTML><TITLE>{}</TITLE>\n'.format(title))
    ciftify.html.write_header(htmlindex)
    htmlindex.write('<body>\n')
    ## writing the navigation bar
    nav_list = [{'href': "", 'label':'View:'}]
    for scene_dict in scene_list:
        if scene_dict['MakeIndex']==True:
            nav_list.append({ 'href': "{}.html".format(scene_dict['Name']),
                               'label': scene_dict['Name'] })
    for montage_dict in montage_list:
        if montage_dict['MakeIndex']==True:
                nav_list.append({ 'href': "{}.html".format(montage_dict['Name']),
                                   'label': montage_dict['Name'] })
    nav_list.append({'href': "index.html", 'label':'Index'})
    ciftify.html.write_navbar(htmlindex,
                    mapname,
                    nav_list,
                    activelink = indexname)

    ## add the main title
    htmlindex.write('<h1>{}</h1>\n'.format(title))

    # add the pic and a link to the subjects' page
    for subject in subjects:
        subjectpage = os.path.join(qcdir,'{}'.format(subject),'qc.html')
        htmlindex.write('<div class="container" style="width: 100%;">')
        pic = os.path.join(qcdir,'{}'.format(subject) ,pic_name)
        picrelpath = os.path.relpath(pic,os.path.dirname(htmlindex.name))
        subrelpath = os.path.relpath(subjectpage,os.path.dirname(htmlindex.name))
        ciftify.html.add_image(htmlindex, colwidth,
                       subrelpath, picrelpath,
                       "{}".format(subject))
        htmlindex.write('</div>\n</br>')
    ## close the html index stream
    htmlindex.write('</body>\n')
    htmlindex.close()

def write_all_indexpages(qcdir, subjects_filter, mapname, qc_dict):
    '''
    writes the main index pages and them calls write_index to write the rest
    '''
    subjects = ciftify.utilities.get_subj(qcdir)

    if subjects_filter:
        subjects = filter(lambda x: subjects_filter in x, subjects)

    ## read the dictonaries of options
    scene_list = qc_dict['scene_list']
    montage_list = qc_dict['montage_list']

    ## write the major index
    indexhtml = os.path.join(qcdir, 'index.html')
    indexhtml = open(indexhtml,'w')
    indexhtml.write('<!DOCTYPE html>\n<HTML><TITLE>{}</TITLE>\n'.format(mapname))
    ciftify.html.write_header(indexhtml)
    indexhtml.write('<body>\n')

    ## writing the navigation bar
    nav_list = [{'href': "", 'label':'View:'}]
    for scene_dict in scene_list:
        if scene_dict['MakeIndex']==True:
            nav_list.append({ 'href': "{}.html".format(scene_dict['Name']),
                               'label': scene_dict['Name'] })
    for montage_dict in montage_list:
        if montage_dict['MakeIndex']==True:
                nav_list.append({ 'href': "{}.html".format(montage_dict['Name']),
                                   'label': montage_dict['Name'] })
    nav_list.append({'href': "index.html", 'label':'Index'})
    ciftify.html.write_navbar(indexhtml,
                    mapname,
                    nav_list,
                    activelink = 'index.html')

    ## writing the lists to the main index page
    indexhtml.write('<h1>{} Index</h1>\n'.format(mapname))
    indexhtml.write('<h2>All subjects together</h2>\n')
    indexhtml.write('<ul>\n  ')
    for scene_dict in scene_list:
        if scene_dict['MakeIndex']==True:
            indexhtml.write('<li><a href="{}.html">{} View</a></li>\n'.format(scene_dict['Name'], scene_dict['Name']))
    for montage_dict in montage_list:
        if montage_dict['MakeIndex']==True:
                indexhtml.write('<li><a href="{}.html">{} View</a></li>\n'.format(montage_dict['Name'], montage_dict['Name']))
    indexhtml.write('</ul>\n')
    indexhtml.write('<h2>Subject Pages</h2>\n')
    indexhtml.write('<ul>\n  ')
    for subject in subjects:
        indexhtml.write('<li><a href="{}/qc.html">{}</a></li>\n'.format(subject,subject))
    indexhtml.write('</ul>\n')
    indexhtml.write('</body>')
    indexhtml.close()

    for scene_dict in scene_list:
        if scene_dict['MakeIndex']==True:
            write_index(qcdir, subjects, mapname,
                        "{}.png".format(scene_dict['Name']), 12,
                        "{}.html".format(scene_dict['Name']),
                        "{} {} View".format(mapname, scene_dict['Name']),
                        qc_dict)
    for montage_dict in montage_list:
        if montage_dict['MakeIndex']==True:
            write_index(qcdir, subjects, mapname,
                        "{}.png".format(montage_dict['Name']), 12,
                        "{}.html".format(montage_dict['Name']),
                        "{} {} View".format(mapname, montage_dict['Name']),
                        qc_dict)

def main(temp_dir):
    global DEBUG, DRYRUN
    arguments = docopt(__doc__)
    snaps_cifti = arguments['cifti-snaps']
    snaps_nifti = arguments['nifti-snaps']
    index_only = arguments['index']
    DEBUG = arguments['--debug']
    DRYRUN = arguments['--dry-run']
    verbose = arguments['--verbose']

    if verbose:
        logger.setLevel(logging.INFO)

    logger.info(arguments)

    settings = UserSettings(arguments, temp_dir)
    qc_config = ciftify.qc_config.Config(settings.qc_mode)

    ## make pics and qcpage for each subject
    if settings.snap:
        logger.info("Making snaps for subject: {}, " \
            "Map: {}".format(settings.subject, settings.map_name))
        make_snaps(settings, qc_config)

    # ## Start the index html file
    # if index_only:
    #     logger.info("Writing Index pages to: {}".format(qcdir))
    #     write_all_indexpages(qcdir, subjects_filter, mapname, qc_dict)

def make_snaps(settings, qc_config):
    '''
    Does all the file manipulation and takes that pics for one subject
    '''
    qc_subdir = os.path.join(settings.qc_dir, '{}_{}'.format(settings.subject,
            settings.map_name))

    if os.path.exists(qc_subdir):
        logger.info('Subject {}, Map {} already has qc files. " \
                "Exiting'.format(settings.subject, settings.map_name))
        return

    with ciftify.utilities.TempSceneDir(settings.hcp_dir,
            settings.subject) as scene_dir:
        generate_qc_page(settings, qc_config, scene_dir, qc_subdir)

def generate_qc_page(settings, qc_config, scene_dir, qc_subdir):
    scene_file = personalize_template(qc_config.template, scene_dir, settings)

    if DRYRUN:
        return

    ciftify.utilities.make_dir(qc_subdir, DRYRUN)
    qc_html = os.path.join(qc_subdir, 'qc.html')
    with open(qc_html, 'w') as qc_page:
        ciftify.utilities.add_page_header(qc_page, qc_config, settings.map_name,
                subject=settings.subject, path='..')
        ciftify.utilities.add_images(qc_page, qc_subdir, qc_config.images,
                scene_file)

def personalize_template(template, scene_dir, settings):
    with open(template, 'r') as template_txt:
        template_contents = template_txt.read()

    if not template_contents:
        logger.error("{} cannot be read or is empty".format(template))
        sys.exit(1)

    scene_file = os.path.join(scene_dir,'{}_{}.scene'.format(settings.subject,
            settings.map_name))

    with open(scene_file, 'w') as scene_stream:
        new_text = modify_template_contents(template_contents, scene_file,
                settings)
        scene_stream.write(new_text)

    return scene_file

def modify_template_contents(template_contents, scene_file, settings):
    modified_text = template_contents.replace('HCP_DATA_PATH', settings.hcp_dir)
    modified_text = modified_text.replace('HCP_DATA_RELPATH',
            os.path.relpath(settings.hcp_dir, os.path.dirname(scene_file)))
    modified_text = modified_text.replace('SUBJID', settings.subject)
    modified_text = modified_text.replace('SEEDCORRDIR', os.path.dirname(
            os.path.realpath(settings.snap)))
    modified_text = modified_text.replace('SEEDCORRRELDIR', os.path.relpath(
            os.path.dirname(os.path.realpath(settings.snap)),
            os.path.dirname(scene_file)))
    modified_text = modified_text.replace('SEEDCORRCIFTI', os.path.basename(
            os.path.realpath(settings.snap)))
    return modified_text

class UserSettings(VisSettings):
    def __init__(self, arguments, temp_dir):
        self.temp = temp_dir
        VisSettings.__init__(self, arguments, qc_mode='mapvis')
        self.map_name = arguments['<map-name>']
        self.subject = arguments['<subject>']
        self.resample = arguments['--resample-nifti']
        self.snap = self.__get_cifti(arguments)
        self.overlay = arguments['--roi-overlay']
        self.subject_filter = arguments['--subjects-filter']
        self.save_dscalar = arguments['--output-dscalar']

    def __get_cifti(self, arguments):
        nifti = arguments['<map.nii>']
        palette = arguments['--colour-palette']
        if nifti is None:
            cifti_path = arguments['<map.dscalar.nii>']
            cifti = self.__change_palette(cifti_path, palette, copy=True)
            return cifti
        new_cifti = self.__convert_nifti(nifti)
        cifti = self.__change_palette(new_cifti, palette)
        return output

    def __change_palette(self, cifti, palette, copy=False):
        if palette is None or cifti is None:
            return cifti
        if copy:
            # Copy the original cifti to the temp dir
            original = cifti
            cifti = os.path.join(self.temp, os.path.basename(original))
            ciftify.utilities.docmd(['cp', original, cifti])
        # Change to the given palette
        cmd = ['wb_command', '-cifti-palette', cifti, 'MODE_AUTO_SCALE', cifti,
                '-palette-name', palette]
        ciftify.utilities.docmd(cmd)
        return cifti

    def __convert_nifti(self, nifti):
        cifti_name = '{}.dscalar.nii'.format(self.map_name)
        output = os.path.join(self.temp, cifti_name)
        subject_hcp_dir = os.path.join(self.hcp_dir, self.subject)
        cmd = ['ciftify-a-nifti', nifti, subject_hcp_dir, output]
        if self.resample:
            cmd.append('--resample-voxels')
        ciftify.utilities.docmd(cmd, DRYRUN)
        return output

if __name__=='__main__':
    with ciftify.utilities.TempDir() as temp_dir:
        logger.info('Creating temp dir:{} on host:{}'.format(temp_dir,
                os.uname()[1]))
        ret = main(temp_dir)
    sys.exit(ret)
